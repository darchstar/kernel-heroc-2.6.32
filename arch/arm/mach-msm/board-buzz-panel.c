/*
 * Copyright (C) 2008 HTC Corporation.
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/platform_device.h>
#include <linux/delay.h>
#include <linux/leds.h>
#include <linux/clk.h>
#include <linux/err.h>

#include <asm/io.h>
#include <asm/gpio.h>
#include <asm/mach-types.h>

#include <mach/msm_panel.h>
#include <mach/msm_fb.h>
#include <mach/vreg.h>
#ifdef CONFIG_HTC_PWRSINK
#include <mach/htc_pwrsink.h>
#endif

/* #include <mach/pmic.h> */
#include "board-buzz.h"
#include "proc_comm.h"
#include "devices.h"

#if 0
#define B(s...) printk("[panel]"s)
#else
#define B(s...) do {} while(0)
#endif

struct mddi_table {
	uint32_t reg;
	uint32_t value;
	uint32_t msec;
};

static struct mddi_table buzz_init_tb[] = {
	{0x01,	0x00, 0},
	{0x3E,	0x3C, 0},
	{0x16,	0x08, 0},
	{0x21,	0x00, 0},
	{0x23,	0xA3, 0},
	{0x27,	0x02, 0},
	{0x28,	0x07, 0},
	{0x40,	0x74, 0},
	{0x41,	0xF0, 0},
	{0x71,	0x68, 0},
	{0x60,	0x01, 0},
	{0x93,	0x0F, 0},
	{0x98,	0x0F, 0},
	{0x9A,	0x00, 10},
	{0x1B,	0x10, 40},
	{0x1C,	0x04, 10},
	{0x1F,	0x09, 10},
	{0x43,	0x80, 60},
	{0xD0,	0x00, 0},
	{0xD1,	0x01, 0},
	{0xD2,	0x01, 0},
	{0xD3,	0x05, 0},
	{0xD4,	0x14, 0},
	{0xD5,	0x3F, 0},
	{0xD6,	0x01, 0},
	{0xD7,	0x09, 0},
	{0xD8,	0x01, 0},
	{0xD9,	0x0B, 0},
	{0xDA,	0x11, 0},
	{0xDB,	0x16, 0},
	{0xDC,	0x17, 0},
	{0xDD,	0x16, 0},
	{0xDE,	0x17, 0},
	{0xDF,	0x0C, 0},
	{0xE0,	0x10, 0},
	{0xE1,	0x00, 0},
	{0xE2,	0x2B, 0},
	{0xE3,	0x3A, 0},
	{0xE4,	0x3E, 0},
	{0xE5,	0x3E, 0},
	{0xE6,	0x3F, 0},
	{0xE7,	0x4E, 0},
	{0xE8,	0x55, 0},
	{0xE9,	0x0F, 0},
	{0xEA,	0x13, 0},
	{0xEB,	0x08, 0},
	{0xEC,	0x0A, 0},
	{0xED,	0x09, 0},
	{0xEE,	0x09, 0},
	{0xEF,	0x0F, 0},
	{0xF0,	0x15, 0},
	{0xF1,	0x1E, 0},
	{0xF2,	0x0F, 0},
	{0x5F,	0x01, 0},
	{0x95,	0x24, 0},
	{0x96,	0x00, 1},
	{0x02,	0x00, 0},
	{0x03,	0x00, 0},
	{0x04,	0x00, 0},
	{0x05,	0xEF, 0},
	{0x06,	0x00, 0},
	{0x07,	0x00, 0},
	{0x08,	0x01, 0},
	{0x09,	0x3F, 0},
	{0x26,	0x24, 1},
	{0x26,	0x38, 1},
	{0x26,	0x3C, 0},
};

static struct mddi_table buzz_standby_tb[] = {
	{0x95, 0x0000, 0},
	{0x26, 0x0038, 50},
        {0x26, 0x0020, 50},
};

static struct mddi_table buzz_tpo_adjust_tb[] = {
	{0x02, 0x0000, 0},
	{0x03, 0x0000, 0},
	{0x04, 0x0000, 0},
	{0x05, 0x00ef, 0},
	{0x06, 0x0000, 0},
	{0x07, 0x0000, 0},
	{0x08, 0x0001, 0},
	{0x09, 0x003f, 0},
};

struct lcm_va_cmd buzz_gamma_init_seq[] = {
CMD_VECT(0x5e, 0,
0x00, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
0x1C, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x2D, 0x00, 0x00, 0x00,
0x36, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00,
0x52, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00,
0x6A, 0x00, 0x00, 0x00, 0x73, 0x00, 0x00, 0x00, 0x7B, 0x00, 0x00, 0x00,
0x84, 0x00, 0x00, 0x00, 0x8F, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00,
0xA1, 0x00, 0x00, 0x00, 0xA8, 0x00, 0x00, 0x00, 0xAF, 0x00, 0x00, 0x00,
0xB6, 0x00, 0x00, 0x00, 0xBD, 0x00, 0x00, 0x00, 0xC5, 0x00, 0x00, 0x00,
0xCB, 0x00, 0x00, 0x00, 0xD2, 0x00, 0x00, 0x00, 0xDA, 0x00, 0x00, 0x00,
0xE1, 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00, 0xEE, 0x00, 0x00, 0x00,
0xF5, 0x00, 0x00, 0x00, 0xFA, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00,
0x0C, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0xDA, 0x00, 0x00, 0x00,
0x59, 0x00, 0x00, 0x00, 0x49, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
0xD9, 0x00, 0x00, 0x00, 0x7A, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00, 0x00,
0x1A, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00,
0x31, 0x00, 0x00, 0x00, 0x3A, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00,
0x4A, 0x00, 0x00, 0x00, 0x51, 0x00, 0x00, 0x00, 0x58, 0x00, 0x00, 0x00,
0x5F, 0x00, 0x00, 0x00, 0x67, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x00, 0x00,
0x77, 0x00, 0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x86, 0x00, 0x00, 0x00,
0x8E, 0x00, 0x00, 0x00, 0x96, 0x00, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00,
0xA5, 0x00, 0x00, 0x00, 0xAB, 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00,
0xB8, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00,
0xCD, 0x00, 0x00, 0x00, 0xD5, 0x00, 0x00, 0x00, 0xDC, 0x00, 0x00, 0x00,
0xE4, 0x00, 0x00, 0x00, 0xEB, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00,
0x14, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
0xEB, 0x00, 0x00, 0x00, 0x6B, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
0x86, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00,
0x15, 0x00, 0x00, 0x00, 0x1A, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
0x27, 0x00, 0x00, 0x00, 0x2E, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
0x3B, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x4B, 0x00, 0x00, 0x00,
0x51, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00, 0x00,
0x63, 0x00, 0x00, 0x00, 0x6B, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00,
0x7C, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x8A, 0x00, 0x00, 0x00,
0x92, 0x00, 0x00, 0x00, 0x9A, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00, 0x00,
0xA6, 0x00, 0x00, 0x00, 0xAC, 0x00, 0x00, 0x00, 0xB2, 0x00, 0x00, 0x00,
0xB9, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00, 0xC6, 0x00, 0x00, 0x00,
0xCF, 0x00, 0x00, 0x00, 0xD8, 0x00, 0x00, 0x00, 0xE1, 0x00, 0x00, 0x00,
0x3A, 0x00, 0x00, 0x00, 0x61, 0x00, 0x00, 0x00, 0xBF, 0x00, 0x00, 0x00,
0xFB, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
0x58, 0x00, 0x00, 0x00, 0xF2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
),
};

struct lcm_va_cmd auo_init_seq[] = {
        CMD_VECT(0xf0,  0, 0x5a, 0x00, 0x00, 0x00),
        CMD_VECT(0xf3,  0, 0x00, 0x00, 0x00, 0x00),
        CMD_VECT(0xf1,  0, 0x5a, 0x00, 0x00, 0x00),
        CMD_VECT(0xff,  0, 0x00, 0x00, 0x00, 0x40),
        CMD_VECT(0x11, 10, 0x00, 0x00, 0x00, 0x00),

        CMD_VECT(0xfd,  0, 0x11, 0x02, 0x00, 0x00),
        CMD_VECT(0xf3,  0, 0x01, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0xf4,  0, 0x6B, 0x6B, 0x6C, 0x6C, 0x44, 0x00, 0x00, 0x00),
        CMD_VECT(0xf5, 10, 0x12, 0x00, 0x05, 0x00, 0x00, 0x1f, 0x00, 0x00),
        CMD_VECT(0xf3, 20, 0x03, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0xff, 10, 0x00, 0x00, 0x00, 0x60),

        CMD_VECT(0xf3, 10, 0x07, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0xff, 10, 0x00, 0x00, 0x00, 0x70),
        CMD_VECT(0xf3,  0, 0x0f, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0xff, 10, 0x00, 0x00, 0x00, 0x78),
        CMD_VECT(0xf3, 20, 0x1f, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),

        CMD_VECT(0xf3, 30, 0x3f, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0xf6,  0, 0x00, 0x08, 0x00, 0x00),
        CMD_VECT(0x2a,  0, 0x00, 0x00, 0x00, 0xef),
        CMD_VECT(0x2b,  0, 0x00, 0x00, 0x01, 0x3f),

        CMD_VECT(0xf7, 0, 0x80, 0x0b, 0x12, 0x30, 0x3a, 0x39, 0x3c, 0x3e,
                        0x00, 0x05, 0x20, 0x10, 0x0b, 0x3a, 0x10, 0x00),
        CMD_VECT(0xf8, 30, 0x80, 0x0b, 0x12, 0x30, 0x3a, 0x39, 0x3c, 0x3e,
                        0x00, 0x05, 0x20, 0x10, 0x0b, 0x3a, 0x10, 0x00),
        CMD_VECT(0xf9, 30, 0x80, 0x0b, 0x12, 0x30, 0x38, 0x3a, 0x3b, 0x3f,
                        0x03, 0x06, 0x1a, 0x10, 0x05, 0x3a, 0x10, 0x00),
        CMD_VECT(0xfa, 20, 0x80, 0x0b, 0x12, 0x30, 0x38, 0x3a, 0x3b, 0x3f,
                        0x03, 0x06, 0x1a, 0x10, 0x05, 0x3a, 0x10, 0x00),
        CMD_VECT(0xfb,  0, 0x80, 0x0b, 0x12, 0x30, 0x37, 0x37, 0x36, 0x39,
                        0x0a, 0x12, 0x33, 0x27, 0x18, 0x3a, 0x10, 0x00),
        CMD_VECT(0xfc, 30, 0x80, 0x0b, 0x12, 0x30, 0x37, 0x37, 0x36, 0x39,
                        0x0a, 0x12, 0x33, 0x27, 0x18, 0x3a, 0x10, 0x00),

        CMD_VECT(0xf1,  0, 0x00, 0x00, 0x00, 0x00),
        CMD_VECT(0xf3, 30, 0x7f, 0x00, 0x00, 0x07, 0x33, 0x75, 0x66, 0x2c),
        CMD_VECT(0x3a,  0, 0x06, 0x00, 0x00, 0x00),
        CMD_VECT(0x36,  0, 0x48, 0x00, 0x00, 0x00),
        CMD_VECT(0xf2, 30, 0x1a, 0x1a, 0x03, 0x08, 0x08, 0x08, 0x08, 0x10,
			0x00, 0x17, 0x17, 0x00),
        CMD_VECT(0xe0,  0, 0x01, 0x00, 0x00, 0x00),
        CMD_VECT(0xe1,  0, 0xff, 0xf8, 0x00, 0x00),
        CMD_VECT(0x29,  0, 0x00, 0x00, 0x00, 0x00),
        CMD_VECT(0xcd,  0, 0x47, 0x17, 0x00, 0x00),
        CMD_VECT(0x35,  0, 0x00, 0x00, 0x00, 0x00),
};

struct lcm_va_cmd auo_deinit_seq[] = {
	CMD_VECT(0xf3, 0, 0x80, 0x00, 0x00, 0x00),
	CMD_VECT(0x10, 30, 0x00, 0x00, 0x00, 0x00),
};

struct lcm_va_cmd auo_adjust_seq[] = {
	CMD_VECT(0x2a, 0, 0x00, 0x00, 0x00, 0xef),
	CMD_VECT(0x2b, 0, 0x00, 0x00, 0x01, 0x3f),
};

#define GPIOSEL_VWAKEINT (1U << 0)
#define INTMASK_VWAKEOUT (1U << 0)

enum {
	PANEL_TPO = 0,
	PANEL_AUO = 1,
};

#if defined(CONFIG_ARCH_MSM7225) || defined(CONFIG_ARCH_MSM7625)
#define LCM_ID0 57
#define LCM_ID1 58
#else
#define LCM_ID0 _bad_id()
#define LCM_ID1 _bad_id()
#endif

static int
buzz_panel_detect(void)
{
	int panel_id = 0;
	if(!gpio_get_value(LCM_ID0) && !gpio_get_value(LCM_ID1)) {
		panel_id = PANEL_TPO;
	} else if (gpio_get_value(LCM_ID0) && gpio_get_value(LCM_ID1)) {
		panel_id = PANEL_AUO;
	}

	return panel_id;
}


static int
buzz_panel_shrink(int brightness)
{
	int panel_id;
	panel_id = buzz_panel_detect();
	/* AUO and TPO  panel have different brightness performance,
	 * need to reduce AUO's PWM duty to be consistent with TPO panel.
	 */
	if (brightness <= 142) {
		if (brightness <= 30) {
			if(panel_id == PANEL_TPO)
				brightness = 9;
			else
				brightness = 8;
		} else {
			if(panel_id == PANEL_TPO)
				brightness = 117 * (brightness - 30) / 112 + 9;
			else
				brightness = 102 * (brightness - 30) / 112 + 8;
		}
	} else {
		if(panel_id == PANEL_TPO)
			brightness =  129 * (brightness - 142) / 113 + 126;
		else
			brightness =  98 * (brightness - 142) / 113 + 110;
	}
	return brightness;
}

static void
buzz_process_mddi_table(struct msm_mddi_client_data *client_data,
		struct mddi_table *table, ssize_t count)

{
	int i;
	uint32_t reg, value, msec;

	BUG_ON(!client_data);
	BUG_ON(!table);
	BUG_ON(!count);

	for(i = 0; i < count; i++) {
		reg = table[i].reg;
		value = table[i].value;
		msec = table[i].msec;

		client_data->remote_write(client_data, value, reg);
		if (msec)
			hr_msleep(msec);
	}
}

static void
buzz_process_mddi_cmd(struct msm_mddi_client_data *client_data,
                struct lcm_va_cmd *table, ssize_t count)
{
	struct lcm_va_cmd *pcmd = NULL;

	BUG_ON(!client_data);
	BUG_ON(!table);
	BUG_ON(!count);

	for (pcmd = table; pcmd < table + count; pcmd++) {
		client_data->remote_write_vals(client_data, pcmd->value,
			pcmd->reg, pcmd->size);
		if (pcmd->delay)
			hr_msleep(pcmd->delay);
	}
}

static struct vreg *vreg_lcm_2v85;
static struct vreg *vreg_lcm_2v6;

static void
buzz_mddi_power_client(struct msm_mddi_client_data *cdata, int on)
{
	unsigned id, on_off;
	B("%s: enter.\n", __func__);

	if(on) {
		B("buzz resume");
		on_off = 0;

                gpio_set_value(BUZZ_MDDI_RSTz, 0);

                vreg_enable(vreg_lcm_2v6);
                vreg_enable(vreg_lcm_2v85);

                id = PM_VREG_PDOWN_GP2_ID;
                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);

                id = PM_VREG_PDOWN_GP4_ID;
                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);


                hr_msleep(10);

                gpio_set_value(BUZZ_MDDI_RSTz, 1);
                hr_msleep(50);
	} else {
		B("buzz suspend");
                on_off = 1;

                hr_msleep(20);
                vreg_disable(vreg_lcm_2v85);
		vreg_disable(vreg_lcm_2v6);

                id = PM_VREG_PDOWN_GP4_ID;
                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);

                id = PM_VREG_PDOWN_GP2_ID;
                msm_proc_comm(PCOM_VREG_PULLDOWN, &on_off, &id);

                hr_msleep(10);

                gpio_set_value(BUZZ_MDDI_RSTz, 0);
	}
}

static int
buzz_mddi_client_init(struct msm_mddi_bridge_platform_data *bridge_data,
		     struct msm_mddi_client_data *client_data)
{
	int panel_id;
	BUG_ON(!bridge_data);
	BUG_ON(!client_data);
	B("%s: enter.\n", __func__);

	panel_id = buzz_panel_detect();
	client_data->auto_hibernate(client_data, 0);
	if (panel_id == PANEL_TPO) {
		buzz_process_mddi_cmd(client_data,
			buzz_gamma_init_seq,
			ARRAY_SIZE(buzz_gamma_init_seq));
		buzz_process_mddi_table(client_data,
			buzz_init_tb,
			ARRAY_SIZE(buzz_init_tb));
	} else
		buzz_process_mddi_cmd(client_data,
			auo_init_seq,
			ARRAY_SIZE(auo_init_seq));
	client_data->auto_hibernate(client_data, 1);

        return 0;

}

static int
buzz_mddi_client_uninit(struct msm_mddi_bridge_platform_data *bridge_data,
			struct msm_mddi_client_data *client_data)

{
	int panel_id;
	BUG_ON(!bridge_data);
	BUG_ON(!client_data);
	B("%s: enter.\n", __func__);

	panel_id = buzz_panel_detect();
	client_data->auto_hibernate(client_data, 0);
	if(panel_id == PANEL_TPO)
		buzz_process_mddi_table(client_data,
			buzz_standby_tb,
			ARRAY_SIZE(buzz_standby_tb));
	else
		buzz_process_mddi_cmd(client_data,
			auo_deinit_seq,
			ARRAY_SIZE(auo_deinit_seq));
	client_data->auto_hibernate(client_data, 1);

        return 0;
}

static int
buzz_panel_unblank(struct msm_mddi_bridge_platform_data *bridge_data,
                  struct msm_mddi_client_data *client_data)
{
	B("%s enter\n", __func__);
	return 0;
}

static int
buzz_panel_blank(struct msm_mddi_bridge_platform_data *bridge_data,
                struct msm_mddi_client_data *client_data)
{
	B("%s enter\n", __func__);
	return 0;
}

static void
buzz_tpo_panel_adjust(struct msm_mddi_client_data *client_data)
{
	B("%s\n", __func__);
	client_data->auto_hibernate(client_data, 0);
	buzz_process_mddi_table(client_data, buzz_tpo_adjust_tb,
		ARRAY_SIZE(buzz_tpo_adjust_tb));
	client_data->auto_hibernate(client_data, 1);
}

static void
buzz_auo_panel_adjust(struct msm_mddi_client_data *client_data)
{
	B("%s\n", __func__);
	client_data->auto_hibernate(client_data, 0);
	buzz_process_mddi_cmd(client_data, auo_adjust_seq,
		ARRAY_SIZE(auo_adjust_seq));
	client_data->auto_hibernate(client_data, 1);
}

static int buzz_change_cabcmode(
	struct msm_mddi_client_data *client_data, int mode, u8 dimming)
{
	B("%s enter\n", __func__);
	return 0;
}

static void
buzz_fixup(uint16_t *mfr_name, uint16_t *product_code)
{
	int panel_id;
	B("%s: enter.\n", __func__);
	panel_id = buzz_panel_detect();
	if(panel_id == PANEL_TPO) {
		*mfr_name = 0x4858;
		*product_code = 0x8356;
	} else {
		*mfr_name = 0x0101;
		*product_code = 0x04d1;
	}

}

static struct resource resources_msm_fb[] = {
        {
                .start = MSM_FB_BASE,
                .end = MSM_FB_BASE + MSM_FB_SIZE - 1,
                .flags = IORESOURCE_MEM,
        },
};

static struct msm_mddi_bridge_platform_data himax_client_data = {
        .init = buzz_mddi_client_init,
        .uninit = buzz_mddi_client_uninit,
	.bridge_type = SAMSUNG_D,
        .blank = buzz_panel_blank,
        .unblank = buzz_panel_unblank,
        .fb_data = {
                .xres = 240,
                .yres = 320,
		.width = 49,
		.height = 65,
                .output_format = 0,
        },
};

static struct msm_mddi_platform_data buzz_pdata = {
	.clk_rate = 83000000,		/*default MDDI frequenct*/
	.power_client = buzz_mddi_power_client,
	.fixup = buzz_fixup,
	.fb_resource = resources_msm_fb,
	.num_clients = 2,
	.client_platform_data = {
		{
			.product_id = (0x4858 << 16 | 0x8356),
			.name = "mddi_c_4858_8356",
			.id = 0,
			.client_data = &himax_client_data,
			.clk_rate = 0,
		},
		{
			.product_id = (0x0101 << 16 | 0x04d1),
			.name = "mddi_c_0101_04d1",
			.id = 0,
			.client_data = &himax_client_data,
			.clk_rate = 0,
		},
	},
};

static struct msm_mdp_platform_data mdp_pdata = {
        .color_format = MSM_MDP_OUT_IF_FMT_RGB666,
};


int __init buzz_panel_init(void)
{
	int rc, panel_id;
	struct panel_data *config = &himax_client_data.panel_conf;
	struct msm_mddi_bridge_platform_data *bridge_data = &himax_client_data;

	B("buzz panel_init");
	vreg_lcm_2v85 = vreg_get(0, "gp4");
	if (IS_ERR(vreg_lcm_2v85))
		return PTR_ERR(vreg_lcm_2v85);

	vreg_lcm_2v6 = vreg_get(0, "gp2");
	if (IS_ERR(vreg_lcm_2v6))
		return PTR_ERR(vreg_lcm_2v6);


	msm_device_mdp.dev.platform_data = &mdp_pdata;
	rc = platform_device_register(&msm_device_mdp);
	if (rc)
		return rc;

	config->caps = MSMFB_CAP_CABC;
	config->change_cabcmode = buzz_change_cabcmode;
	config->shrink = 1;
	config->shrink_br = buzz_panel_shrink;

	panel_id = buzz_panel_detect();

	if(panel_id == PANEL_TPO) {
		bridge_data->adjust = buzz_tpo_panel_adjust;
		buzz_pdata.clk_rate = 73846000;
	}
	else
		bridge_data->adjust = buzz_auo_panel_adjust;

	msm_device_mddi0.dev.platform_data = &buzz_pdata;
	rc = platform_device_register(&msm_device_mddi0);
	if (rc)
		return rc;

	return 0;
}
